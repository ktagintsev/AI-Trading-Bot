import random
import numpy as np
from utils import quality, downsample
from config import bounds, timeframes, settings

def levy_flight(Lambda):
    """
    Generates a step size using the Lévy flight distribution.

    Lévy flight is a random walk where the step lengths have a probability
    distribution that is heavy-tailed. This is used to simulate the random
    movement of cuckoos in the search space.

    Args:
        Lambda (float): The power-law exponent for the Lévy distribution.

    Returns:
        float: The step size generated by the Lévy flight.
    """
    u = np.random.normal(0, 1)  # Random value from a normal distribution
    v = np.random.normal(0, 1)  # Random value from a normal distribution
    step = u / abs(v) ** (1 / Lambda)  # Lévy flight step size
    return step

def cuckoo_search(price_series, log=None, setting=None):
    """
    Implements the Cuckoo Search (CS) optimization algorithm.

    Cuckoo Search is a nature-inspired optimization algorithm based on the
    brood parasitism of some cuckoo species. It uses Lévy flights for
    exploration and a probability of abandoning nests to introduce diversity.

    Args:
        price_series (list or np.ndarray): The input price series data.
        log (list, optional): A list to store the best fitness values for each generation.
        setting (dict, optional): A dictionary containing algorithm parameters.
                                  Defaults to the first configuration in `settings["CS"]`.

    Returns:
        tuple: A tuple containing:
            - best_nest (np.ndarray): The best solution found.
            - best_fitness (float): The fitness value of the best solution.
            - best_timeframe (int): The timeframe corresponding to the best solution.
    """
    if setting is None:
        setting = settings["CS"][0]  # Use default settings if none are provided

    # Extract algorithm parameters
    NUM_NESTS = setting["NUM_NESTS"]  # Number of nests (solutions)
    MAX_ITER = setting["MAX_ITER"]  # Maximum number of iterations
    pa = setting["pa"]  # Probability of abandoning a nest

    dim = len(bounds)  # Dimensionality of the search space

    # Initialize nests (solutions) randomly within the bounds
    nests = [np.array([random.uniform(low, high) for (low, high) in bounds]) for _ in range(NUM_NESTS)]
    # Evaluate the fitness of each nest
    fitness = [quality(n[:-1], downsample(price_series, timeframes[int(n[-1])])) for n in nests]

    # Identify the best nest (solution) and its fitness
    best_idx = np.argmax(fitness)
    best_nest = nests[best_idx].copy()
    best_fitness = fitness[best_idx]

    # Main optimization loop
    for gen in range(MAX_ITER):
        # Perform Lévy flight and update nests
        for i in range(NUM_NESTS):
            step_size = levy_flight(1.5)  # Generate step size using Lévy flight
            new_nest = nests[i] + step_size * (nests[i] - best_nest)  # Update nest position

            # Ensure the new nest is within bounds
            for d in range(dim - 1):
                new_nest[d] = max(min(new_nest[d], bounds[d][1]), bounds[d][0])
            new_nest[-1] = int(round(max(min(new_nest[-1], bounds[-1][1]), bounds[-1][0])))

            # Evaluate the fitness of the new nest
            tf = timeframes[int(new_nest[-1])]
            new_fit = quality(new_nest[:-1], downsample(price_series, tf))

            # Update the nest if the new fitness is better
            if new_fit > fitness[i]:
                nests[i] = new_nest
                fitness[i] = new_fit

                # Update the best nest if the new fitness is the best so far
                if new_fit > best_fitness:
                    best_nest = new_nest
                    best_fitness = new_fit

        # Abandon some nests and replace them with new random solutions
        for i in range(NUM_NESTS):
            if random.random() < pa:
                nests[i] = np.array([random.uniform(low, high) for (low, high) in bounds])
                tf = timeframes[int(nests[i][-1])]
                fitness[i] = quality(nests[i][:-1], downsample(price_series, tf))

        # Log the best fitness value if a log is provided
        if log is not None:
            log.append(best_fitness)

        # Print the progress of the algorithm
        print(f"CS Gen {gen+1:02d} | Best Profit: ${best_fitness:.2f} | TF: {timeframes[int(best_nest[-1])]}h")

    # Return the best solution, its fitness, and the corresponding timeframe
    return best_nest, best_fitness, timeframes[int(best_nest[-1])]